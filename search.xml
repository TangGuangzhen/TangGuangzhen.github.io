<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2019%2F08%2F05%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式单例模式的两种方式：一种是饿汉式，就是在类初始化的时候，创建对象，这种方式是线程安全的，在程序运行期间就这一个对象。另一种是懒汉式，懒汉式是在第一次使用时才创建对象，但是如果在多线程环境中要考虑线程安全问题。饿汉：饿了，饥不择食，系统一运行就创建对象，不考虑太多的问题；懒汉：就是懒，就是不想创建对象，即使运行创建对象，也要说一大堆的问题，什么多线程、安全，对象重复等问题。总之一句话：懒，就是不想创建。 饿汉式12345678910public class Singletion&#123; // 直接创建对象 private static final Singleton instance = new Singletion(); // 私有化构造函数 private Singletion()&#123;&#125; // 返回对象实例 public static Singletion getInstance()&#123; return instance; &#125;&#125; 懒汉式1234567891011121314151617public class Singletion&#123; // 声明变量 private static volatile Singletion instance = null; // 私有构造函数 private Singletion()&#123;&#125; // 提供对外方法 public static Singletion getSingletion()&#123; if(instance == null)&#123; synchronized(Singletion.class)&#123; if(instance == null)&#123; instance = new Singletion(); &#125; &#125; &#125; return instance; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap]]></title>
    <url>%2F2019%2F08%2F05%2FHashMap%2F</url>
    <content type="text"><![CDATA[在JDK1.6，JDK1.7中，HashMap采用位桶+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，HashMap采用位桶+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。 HashMap的实现原理：首先有一个每个元素都是链表（可能表述不准确）的数组，当添加一个元素（key-value）时，就首先计算元素key的hash值，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，但是形成了链表，同一个链表上的Hash值是相同的，所以说数组存放的是链表。而当链表长度太长时，链表就转换为红黑树，这样大大提高了查找的效率。 加载因子（默认0.75）为什么需要使用加载因子，为什么需要扩容呢？当链表数组的容量超过初始容量的0.75时，再散列将链表数组扩大2倍，把原链表数组的搬移到新的数组中.因为如果填充比很大，说明利用的空间很多，如果一直不进行扩容的话，链表就会越来越长，这样查找的效率很低，因为链表的长度很大（当然最新版本使用了红黑树后会改进很多），扩容之后，将原来链表数组的每一个链表分成奇偶两个子链表分别挂在新链表数组的散列位置，这样就减少了每个链表的长度，增加查找效率 为什么HashMap链表长度超过8会转成树结构？HashMap在JDK1.8及以后的版本中引入了红黑树结构，若桶中链表元素个数大于等于8时，链表转换成树结构；若桶中链表元素个数小于等于6时，树结构还原成链表。因为红黑树的平均查找长度是log(n)，长度为8的时候，平均查找长度为3，如果继续使用链表，平均查找长度为8/2=4，这才有转换为树的必要。链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。还有选择6和8，中间有个差值7可以有效防止链表和树频繁转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树和AVL树的区别]]></title>
    <url>%2F2019%2F08%2F05%2F%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8CAVL%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[互联网公司Java面试知识点—红黑树与AVL树。 AVL树（平衡二叉树）简介AVL树是带有平衡条件的二叉查找树，一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡，左右子树树高度差不超过1，和红黑树相比，AVL树是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差不超过1）。不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而旋转是非常耗时的，由此我们可以知道AVL树适合用于插入与删除次数比较少，但查找多的情况。 局限性由于维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树。 应用Windows NT内核中广泛存在; 红黑树简介一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树（由于是弱平衡，可以看到，在相同的节点情况下，AVL树的高度低于红黑树），相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，我们就用红黑树。 性质 如图1所示，每个节点非红即黑; 每个节点非红即黑； 根节点是黑的; 每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的; 如图所示，如果一个节点是红的，那么它的两儿子都是黑的; 对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点; 每条路径都包含相同的黑节点;应用1，广泛用于C ++的STL中，地图和集都是用红黑树实现的;2，着名的Linux的的进程调度完全公平调度程序，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一颗红黑树上，每个虚拟地址区域都对应红黑树的一个节点，左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间;3，IO多路复用的epoll的的的实现采用红黑树组织管理的的的sockfd，以支持快速的增删改查;4，Nginx的的的中用红黑树管理定时器，因为红黑树是有序的，可以很快的得到距离当前最小的定时器;5，Java的的的中TreeMap中的中的实现; 红黑树和AVL树的区别红黑树和AVL树的区别在于平衡二叉树追求的是全局平衡，而红黑树只追求局部平衡，因此在操作时对红黑树的平衡调整更高效。红黑树并不是严格意义上的左右子树深度差不大于1，但它依然保持平衡，并保持好的查找时间复杂度。 平衡二叉树类型 平衡度 调整频率 适用场景 AVL树 高 高 查询多 红黑树 低 低 插入、删除频繁 参考博客：https://blog.csdn.net/u010899985/article/details/80981053]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易2019校招笔试算法题（Java）]]></title>
    <url>%2F2019%2F08%2F03%2F%E7%BD%91%E6%98%932019%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%88Java%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近在准备秋招的笔试，做了一下网易的秋招笔试题（Java）。话不多说，题目、代码如下。 题目一题目描述小易觉得高数课太无聊了，决定睡觉。不过他对课上的一些内容挺感兴趣，所以希望老师讲到有趣的地方的时候叫醒他一下。你知道了小易对一堂课每分钟知识点的感兴趣程度，并以分数量化，以及他在这堂课上每分钟是否会睡着，你可以叫醒他一次，这会使得他在接下来的k分钟内保持清醒。你需要选择一种方案最大化小易这堂课听到的知识点分值。 输入描述第一行n，k, (1&lt;= n, k&lt;=$10^5$)，表示这堂课持续多少分钟，以及叫醒小易一次使他能够保持清醒的时间。第二行 n个数，$a_{1},a_{2},…, a_{n} (1&lt;= a_{i}&lt;= 10^4)$，表示小易对每分钟知识点的感兴趣评分。第三行 n个数，$t_{1}, t_{2}, …, t_{n}$，表示每分钟小易是否清醒，1表示清醒。 输出描述小易这堂课听到的知识点的最大兴趣值。 示例输入1236 31 3 5 2 5 41 1 0 1 0 0 输出116 思路1暴力法：即先把醒着的分值和wakeSum计算出来,然后我们再遍历每分钟是否醒着，如果为0，那么我们就遍历接下来k个值，把这k个值未醒着的分值加到前面的wakeSum上，然后再去与最大值进行比较更新，直到遍历结束。不过这样由于超时只能过90%的测试用例。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.Scanner;public class wangyi01 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt();//一堂课时长 int k = sc.nextInt();//唤醒能保持清醒的时间 int[] scores = new int[n]; for (int i = 0; i &lt; n; i++) &#123; scores[i] = sc.nextInt(); &#125; int[] sleep = new int[n]; for (int i = 0; i &lt; n; i++) &#123; sleep[i] = sc.nextInt(); &#125; //醒着时的总兴趣值 int wakeSum = 0; for (int i=0;i&lt;n;i++)&#123; if (sleep[i] == 1)&#123; wakeSum += scores[i]; &#125; &#125; int resultMax = 0; int curMax = 0; for (int i=0;i&lt;n;i++)&#123; if (sleep[i] == 0)&#123; curMax = getSum(scores,sleep,i,k);//叫醒期间为0的兴趣值和 curMax = curMax+wakeSum; resultMax = Math.max(resultMax,curMax); &#125; &#125; System.out.println(resultMax); &#125; //遇到为 0 的时候，统计之后的 k 个数，并且跳过为 1 个数字不统计，得到为0的兴趣值和 private static int getSum(int[] scores, int[] sleep, int i, int k)&#123; int res = 0; for (int j=0;j&lt;k;j++)&#123; if (i+j&lt;scores.length)&#123; if (sleep[i+j] == 0) res += scores[i+j]; &#125; &#125; return res; &#125;&#125; 运行结果 思路2我们可以考虑在遍历每分钟是否醒着，不去遍历后面的k个值，而采取利用下标进行计算的方式。这个时候我们就需要利用到累加和的思想了。我们首先定义3个数组，长度都为n。leftScore: 表示从左到右醒着的分值的累加和。rightScore: 表示从右到左醒着的分值的累加和。total: 表示从左到右分数的累加和。然后当我们遍历到为未醒着的位置i时，那么这时的总体分数为3部分之和：leftScore[i-1] + rightScore[i+k] + (total[i+k-1] - total[i-1])。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.Scanner;public class wangyi001 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt();//课长 int k = sc.nextInt();//清醒的时间 int[] scores = new int[n]; for (int i = 0; i &lt; n; i++) &#123; scores[i] = sc.nextInt(); &#125; int[] sleep = new int[n]; for (int i = 0; i &lt; n; i++) &#123; sleep[i] = sc.nextInt(); &#125; int sum = 0; int[] leftscore = new int[n]; for (int i = 0; i &lt; n; i++) &#123; if (sleep[i] == 1) &#123; sum += scores[i]; &#125; leftscore[i] = sum; &#125; int[] rightscore = new int[n]; sum = 0; for (int i = n-1; i &gt; -1; i--) &#123; if (sleep[i] == 1) &#123; sum += scores[i]; &#125; rightscore[i] = sum; &#125; int[] total = new int[n]; sum = 0; for (int i = 0; i &lt; n; i++) &#123; sum += scores[i]; total[i] = sum; &#125; int max = -1; for (int i = 0; i &lt; n; i++) &#123; if (sleep[i] == 0) &#123; int temp = 0; temp += (i - 1) &lt; 0 ? 0 : leftscore[i-1]; temp += (i + k) &gt;= n ? 0 : rightscore[i+k]; temp += total[Math.min(i+k-1, n-1)] - (i - 1 &lt; 0 ? 0 : total[i-1]); if (temp &gt; max) &#123; max = temp; &#125; &#125; &#125; System.out.println(max); &#125;&#125; 运行结果 题目二题目描述又到了丰收的季节，恰好小易去牛牛的果园里游玩。 牛牛常说他多整个果园的每个地方都了如指掌，小易不太相信，所以他想考考牛牛。 在果园里有N堆苹果，每堆苹果的数量为$a_{i}$,小易希望知道从左往右数第x个苹果是属于哪一堆的。 牛牛觉得问题太简单了，所以希望你来替他回答。 输入描述第一行 一个数n(1&lt;=n&lt;=$10^5$)第二行 n个数$a_{i}(1&lt;=a_{i}&lt;=1000)$，表示从左往右数第i堆有多少苹果第三行 一个数m(1&lt;=m&lt;=$10^5$),表示有m次询问第四行 m个数$q_{i}$，表示小易希望知道第$q_{i}$个苹果属于哪一堆。 输出描述m行，第i行输出第$q_{i}$个苹果属于哪一堆。 示例输入123452 7 3 4 931 25 11 输出123153 思路这个题目题意比较好理解，思路也比较简单。首先对苹果数进行累加和。然后再对查询进行二分查找。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Scanner;public class wangyi02 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] apple = new int[n+1]; int cur = 0; for (int i=1;i&lt;=n;i++)&#123; cur += sc.nextInt(); apple[i] = cur; &#125; int m = sc.nextInt(); while (m--&gt;0)&#123; int index = binarySearch(apple,sc.nextInt()); if (index &lt; 0)&#123; System.out.println(-index-1); &#125; else &#123; System.out.println(index); &#125; &#125; &#125; //二分查找 private static int binarySearch(int[] apple, int k)&#123; int start = 1; int end = apple.length-1; int mid = start + (end-start)/2; while (start &lt;= end)&#123; if (apple[mid]&gt;k)&#123; end = mid-1; &#125; else if (apple[mid]&lt;k)&#123; start = mid+1; &#125; else &#123; return mid; &#125; mid = start - (start-end)/2; &#125; return start; &#125;&#125; 运行结果 题目三题目描述给你n个a,m个z组成所有可能的字符串，并将字符串按字典序从小到大排列，输出第k个字符串。若不存在，输出-1。 输入描述第一行为三个数，分别为a的个数n,z的个数m,第k个字符串。 输出描述第k个字符串 示例输入12 2 6 输出1zzaa 思路当给定n和m后，总共有多少中情况：我们很容易得到是$C^m_{m+n}=\frac{(m+n)!}{m!n!}$，如果k大于这个数，即可返回-1。接下来我们用动态规划来做这个题目，假设dp[i][j]表示i个a和j个z的方案数，根据上面这个公式列表计算我们可以发现：d[i][j] = dp[i-1][j] + dp[i][j-1]；这样我们就可以求出方案数。然后我们来求输出字符串。假设我们现在考虑输出字符串的第i个字符，如果当前选了a字符，假设后面剩余字符a和z的个数是m1,n1，那么后面所能组成的字符串总数为dp[m_1][n_1]。如果k小于dp[m_1][n_1]，那么我们就能选a，因为后面组成的数目大于k，我们要选字符a来缩小这个组合数。否则，就选z，这时k -=dp[m_1][n_1]，这是因为要减去a形成的方案数。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.Scanner;public class wangyi03 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int m = sc.nextInt();//a的个数 int n = sc.nextInt();//z的个数 long k = sc.nextInt();//目标,第cur个 long cur = 0; StringBuffer sb = new StringBuffer(); while(m&gt;0&amp;&amp;n&gt;0) &#123;//当a和z均存在时执行 cur = pz(m-1,n,k);//假设a确定，出去a之后剩余a和z的排列组合个数 if(cur&gt;=k) &#123;//如果确定a之后，剩余的排列组合数大于目标，则说明a已确定 sb.append("a"); m--;//a的个数减1 &#125; else &#123;//如果确定a之后，剩余的排列组合数小于目标，则说明不是a。 sb.append("z"); n--;//z的个数减1 k -= cur;//目标减掉排列组合数。因为如果a开头可以有cur中情况， //减掉cur之后即为确定z开头之后，接下来找第k个即可。 &#125; &#125; if(k != 1) &#123;//存在经过计算之后必为1 System.out.println("-1"); return; &#125; else &#123; while(m&gt;0) &#123;//如果z的个数为0，则将a追加到最后即可 sb.append("a"); m--; &#125; while(n&gt;0) &#123;//如果a的个数为0，则将z追加到最后即可 sb.append("z"); n--; &#125; &#125; System.out.print(sb.toString()); &#125; public static long pz(int m,int n,long k) &#123;//计算假设a确定之后，a之后的部分排列组合数 if(m==0||n==0) return 1; long sum = m+n; long cur = 1; n = Math.min(m, n);//C(m+n) n=C(m+n) m 取最小即可 for (int i = 0; i &lt; n ; i++) &#123; cur *= sum-i; cur /= (i+1); if(cur&gt;k)//防止大数。如果cur&gt;k 则只进行list.add("a")和m--//a的个数减1。 //没有k -= cur;因此不影响 break; &#125; return cur; &#125; &#125; 运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>笔试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程笔试题]]></title>
    <url>%2F2019%2F07%2F31%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[同程艺龙JAVA工程师多线程笔试题 笔试题题目问题描述:设计三个线程，三个线程并行执行，要求分别在控制台输入数据后面拼接”_A”，”_B”，”_C”，并且需要保证线程1，线程2，线程3按顺序执行，即线程1执行完成后，再执行线程2，线程2执行完成后再执行线程31.线程运行逻辑：在输入参数中拼接字符串，1号线程拼接”_A”，2号线程拱接_B”， 3号线程拼接”_C”2.程序运行时需要同时启动三个钱程3.线程运行时，需要按照指定顺序运行，1号线程(执行完成) -&gt;2号钱程(执行完威) -&gt;3号线(执行完成)输入描述：字符串输入输入使用Sanner sc = new Sanner(System.in) 获取输入数据输出描述:运算结果输出程序运行结果使用System.out.pintin()输出到控制台输入样例：1Hello 输出样例：1Hello_A_B_C 代码实现12345678910111213141516171819202122232425262728293031323334353637import java.util.Scanner;public class Test &#123; static String str; static class WorkersA implements Runnable &#123; public void run() &#123; str += "_A"; System.out.println("正在运行A"); &#125; &#125; static class WorkersB implements Runnable &#123; public void run() &#123; str += "_B"; System.out.println("正在运行B"); &#125; &#125; static class WorkersC implements Runnable &#123; public void run() &#123; str += "_C"; System.out.println("正在运行C"); &#125; &#125; public static void main(String[] args) throws Exception&#123; Scanner sc = new Scanner(System.in); str = sc.nextLine(); Thread thread1 = new Thread(new WorkersA()); thread1.start(); thread1.join();//使得t.join()中的t优先执行，当t执行完后才会执行其他线程。能够使得线程之间的并行执行变成串行执行。 Thread thread2 = new Thread(new WorkersB()); thread2.start(); thread2.join(); Thread thread3 = new Thread(new WorkersC()); thread3.start(); thread3.join(); System.out.println(str); &#125;&#125;]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络]]></title>
    <url>%2F2019%2F07%2F10%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[计算机网络面试知识点 TCP的三次握手与四次挥手理解 &emsp;&emsp;序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。&emsp;&emsp;确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。&emsp;&emsp;确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效&emsp;&emsp;同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。&emsp;&emsp;终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接&emsp;&emsp;PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。 字段 含义 URG 紧急指针是否有效。为1，表示某一位需要被优先处理 ACK 确认号是否有效，一般置为1。 PSH 提示接收端应用程序立即从TCP缓冲区把数据读走。 RST 对方要求重新建立连接，复位。 SYN 请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1 FIN 希望断开连接。 三次握手过程理解 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 四次挥手过程理解1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 常见面试题问题1：为什么连接的时候是三次握手，关闭的时候却是四次握手？答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 问题2：为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 问题3：为什么不能用两次握手进行连接？答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。 问题4：如果已经建立了连接，但是客户端突然出现故障了怎么办？TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 TCP与UDPTCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。 TCP（Transmission Control Protocol）的概念TCP是一种面向连接的，提供可靠交付服务和全双工通信的，基于字节流的端到端的传输层通信协议。TCP在传输数据之前必须先建立连接，数据传输结束后要释放连接。每一条TCP连接只能有2个端点，故TCP不提供广播或多播服务。TCP提供可靠交付，通过TCP连接传输的数据，无差错、不丢失、不重复、并且按序到达。TCP是面向字节流的。虽然应用进程和TCP的交互是一次一个数据块(大小不等），但TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。TCP并不知道所传输的字节流的含义。 UDP（User Data Protocol，用户数据报协议）（1）UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。（2） 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息。（3）UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。（4） 吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。（5）UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表（这里面有许多参数）。（6）UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。 UDP应用场景：1.面向数据报方式2.网络数据大多为短消息3.拥有大量Client4.对数据安全性无特殊要求5.网络负担非常重，但对响应速度要求高 3. TCP与UDP区别总结：1）TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接2）TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保 证可靠交付3）TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的 UDP没有拥塞控制（），因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）4）每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信5）TCP首部开销20字节;UDP的首部开销小，只有8个字节6）TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道 参考博客：https://blog.csdn.net/qq_38950316/article/details/81087809https://blog.csdn.net/qq_38950316/article/details/81122894]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统]]></title>
    <url>%2F2019%2F07%2F08%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[进程与线程区别联系：1.进程是系统资源分配的最小单位，线程是程序执行的最小单位；2.进程使用独立的数据空间，线程共享进程的数据空间。 线程调度算法1.时间片轮转调度2.先来先服务调度3.优先级调度4.多级反馈队列调度5.高响应比优先调度]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring入门（1）]]></title>
    <url>%2F2019%2F07%2F07%2FSpring%E5%85%A5%E9%97%A8%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Spring的概述 什么是Spring？Spring 是一个开源框架Spring 为简化企业级应用开发而生. 使用Spring可以使简单的JavaBean实现以前只有EJB才能实现的功能Spring 是JavaSE/EE的一站式框架 Spring的概述-Spring的优点• 方便解耦，简化开发– Spring就是一个大工厂，可以将所有对象创建和依赖关系维护，交给Spring管理• AOP编程的支持– Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能• 声明式事务的支持– 只需要通过配置就可以完成对事务的管理，而无需手动编程 • 方便程序的测试– Spring对Junit4支持，可以通过注解方便的测试Spring程序• 方便集成各种优秀框架– Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、 MyBatis等）的直接支持• 降低JavaEE API的使用难度– Spring 对JavaEE开发中非常难用的一些API（JDBC、 JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八大经典排序算法]]></title>
    <url>%2F2019%2F07%2F06%2F%E5%85%AB%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[八大经典排序算法（JAVA版）：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、基数排序 排序算法基础知识术语说明稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；内排序：所有排序操作都在内存中完成；外排序：因数据量太大，故把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；时间复杂度： 一个算法执行所耗费的时间。空间复杂度：运行完一个程序所需内存的大小。 算法总结图片名词解释：n: 数据规模k: “桶”的个数In-place: 占用常数内存，不占用额外内存Out-place: 占用额外内存 算法分类比较和非比较的区别常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr之前有多少个元素，则唯一确定了arr在排序后数组中的位置。非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。 八大排序算法冒泡排序（Bubble Sort）冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 算法描述比较相邻的元素。如果第一个比第二个大，就交换它们两个；对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；针对所有的元素重复以上的步骤，除了最后一个；重复步骤1~3，直到排序完成。 动图演示 代码实现12345678910111213141516171819202122//冒泡排序算法public static void bubbleSort(int[] arr) &#123; // 冒泡排序 的时间复杂度 O(n^2), 自己写出 int temp = 0; // 临时变量 boolean flag = false; // 标识变量，表示是否进行过交换 for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; // 如果前面的数比后面的数大，则交换 if (arr[j] &gt; arr[j + 1]) &#123; flag = true; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; if (!flag) &#123; // 在一趟排序中，一次交换都没有发生过 break; &#125; else &#123; flag = false; // 重置flag!!!, 进行下次判断 &#125; &#125;&#125; 算法分析最佳情况：T(n) = O(n) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(n2) 选择排序（Selection Sort）表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 算法描述n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：初始状态：无序区为R[1..n]，有序区为空；第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；n-1趟结束，数组有序化了。 动图演示 代码实现12345678910111213141516171819//选择排序 public static void selectSort(int[] arr) &#123; //选择排序时间复杂度是 O(n^2) for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minIndex = i; int min = arr[i]; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (min &gt; arr[j]) &#123; // 说明假定的最小值，并不是最小 min = arr[j]; // 重置min minIndex = j; // 重置minIndex &#125; &#125; // 将最小值，放在arr[0], 即交换 if (minIndex != i) &#123; arr[minIndex] = arr[i]; arr[i] = min; &#125; &#125; &#125; 算法分析最佳情况：T(n) = O(n2) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(n2) 插入排序（Insertion Sort）插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 算法描述一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：步骤1：从第一个元素开始，该元素可以认为已经被排序；步骤2：取出下一个元素，在已经排序的元素序列中从后向前扫描；步骤3：如果该元素（已排序）大于新元素，将该元素移到下一位置；步骤4：重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；步骤5：将新元素插入到该位置后；重复步骤2~5。 动图演示 代码实现1234567891011121314151617181920212223242526//插入排序 public static void insertSort(int[] arr) &#123; int insertVal = 0; int insertIndex = 0; //使用for循环来把代码简化 for(int i = 1; i &lt; arr.length; i++) &#123; //定义待插入的数 insertVal = arr[i]; insertIndex = i - 1; // 即arr[1]的前面这个数的下标 // 给insertVal 找到插入的位置 // 说明 // 1. insertIndex &gt;= 0 保证在给insertVal 找插入位置，不越界 // 2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置 // 3. 就需要将 arr[insertIndex] 后移 while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123; arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; &#125; // 当退出while循环时，说明插入的位置找到, insertIndex + 1 // 举例：理解不了，我们一会 debug //这里我们判断是否需要赋值 if(insertIndex + 1 != i) &#123; arr[insertIndex + 1] = insertVal; &#125; &#125; &#125; 算法分析最佳情况：T(n) = O(n) 最坏情况：T(n) = O(n2) 平均情况：T(n) = O(n2) 希尔排序（Shell Sort）希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 算法描述我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；按增量序列个数k，对序列进行k 趟排序；每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 动图演示 代码实现1234567891011121314151617181920212223242526272829303132333435363738public static void shellSort(int[] arr) &#123; int temp = 0; int count = 0; // 根据前面的逐步分析，使用循环处理 for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; // 遍历各组中所有的元素(共gap组，每组有个元素), 步长gap for (int j = i - gap; j &gt;= 0; j -= gap) &#123; // 如果当前元素大于加上步长后的那个元素，说明交换 if (arr[j] &gt; arr[j + gap]) &#123; temp = arr[j]; arr[j] = arr[j + gap]; arr[j + gap] = temp; &#125; &#125; &#125; &#125; &#125; //对交换式的希尔排序进行优化-&gt;移位法 public static void shellSort2(int[] arr) &#123; // 增量gap, 并逐步的缩小增量 for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; // 从第gap个元素，逐个对其所在的组进行直接插入排序 for (int i = gap; i &lt; arr.length; i++) &#123; int j = i; int temp = arr[j]; if (arr[j] &lt; arr[j - gap]) &#123; while (j - gap &gt;= 0 &amp;&amp; temp &lt; arr[j - gap]) &#123; //移动 arr[j] = arr[j-gap]; j -= gap; &#125; //当退出while后，就给temp找到插入的位置 arr[j] = temp; &#125; &#125; &#125; &#125; 算法分析最佳情况：T(n) = O(nlog2 n) 最坏情况：T(n) = O(nlog2 n) 平均情况：T(n) =O(nlog2n) 归并排序（Merge Sort）和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 算法描述把长度为n的输入序列分成两个长度为n/2的子序列；对这两个子序列分别采用归并排序；将两个排序好的子序列合并成一个最终的排序序列。 动图演示 代码实现1234567891011121314151617181920212223242526272829303132/**归并排序 * @param array * @return */ public static int[] MergeSort(int[] array) &#123; if (array.length &lt; 2) return array; int mid = array.length / 2; int[] left = Arrays.copyOfRange(array, 0, mid); int[] right = Arrays.copyOfRange(array, mid, array.length); return merge (MergeSort(left), MergeSort (right)); &#125; /** * 归并排序-将两段排序好的数组结合成一个排序数组 * @param 1eft * @param right * @return */ public static int[] merge(int[] left, int[] right) &#123; int[] result = new int[left.length + right. length]; for (int index = 0, i=0, j=0; index &lt; result.length; index++) &#123; if (i&gt;=left.length) result[index] = right[j++]; else if (j &gt;= right.length) result[index] = left[i++]; else if (left[i] &gt; right[j]) result[index] = right[j++]; else result[index] = left[i++]; &#125; return result; &#125; 算法分析最佳情况：T(n) = O(n) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn) 快速排序（Quick Sort）快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 算法描述快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：从数列中挑出一个元素，称为 “基准”（pivot）；重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 动图演示 代码实现12345678910111213141516171819202122private static void quickSort(int arr[], int left, int right) &#123; if(left &lt; right)&#123; int mid = partition(arr,left,right); quickSort(arr, left, mid); quickSort(arr, mid+1, right); &#125;&#125;private static int partition(int arr[], int left, int right) &#123; int begin_num = arr[left], i = left, j = right; while(i != j)&#123; while(arr[j] &gt;= begin_num &amp;&amp; i!=j)&#123; j--; &#125; arr[i] = arr[j]; while(arr[i] &lt; begin_num &amp;&amp; i!=j)&#123; i++; &#125; arr[j] = arr[i]; &#125; arr[i] = begin_num; return i;&#125; 算法分析最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(nlogn) 堆排序（Heap Sort）堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 算法描述将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 动图演示 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 构建大顶堆 */ public static void adjustHeap(int[] data,int i, int len) &#123; int temp, j; temp = data[i]; for (j = 2*i+1; j &lt; len; j = 2*j+1) &#123; //j为初始化为节点i的左孩子，沿节点较大的子节点向下调整 if (j &lt; len &amp;&amp; data[j] &lt; data[j + 1]) &#123;//取节点较大的子节点的下标 ++j; //如果节点的右孩子&gt;左孩子，则取右孩子节点的下标 &#125; if (temp &gt;= data[j]) &#123; //根节点 &gt;=左右子女中关键字较大者，调整结束 break; &#125;else&#123; //根节点 &lt;左右子女中关键字较大者 data[i] = data[j]; //将左右子结点中较大值data[j]调整到双亲节点上 i = j; //【关键】修改i值，以便继续向下调整 &#125; &#125; data[i] = temp;//被调整的结点的值放入最终位置 &#125; /** * 堆排序 * 时间复杂度：O（n^2） * @param data */ public static void heapSort(int[] data) &#123; int i; //从最后一个节点array.length-1的父节点（array.length-1-1）/2开始，直到根节点0，反复调整堆 for (i = (data.length-2) / 2; i &gt;= 0; i--) &#123; //构建一个大顶堆 adjustHeap(data, i, data.length - 1); &#125; for (i = data.length - 1; i &gt;= 0; i--) &#123; //将堆顶记录和当前未经排序子序列的最后一个记录交换 int temp = data[0]; data[0] = data[i]; data[i] = temp; adjustHeap(data, 0, i - 1); //将a中前i-1个记录重新调整为大顶堆 &#125; &#125;public static void main(String[] args) &#123; int[] arr=&#123;1,3,2,10,5,11,12,4,9,7&#125;; System.out.println("交换之前："); for(int num:arr)&#123; System.out.print(num+" "); &#125; heapSort(arr); System.out.println(); System.out.println("交换后："); for(int num:arr)&#123; System.out.print(num+" "); &#125; &#125; 算法分析最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn) 基数排序基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。 算法描述取得数组中的最大数，并取得位数；arr为原始数组，从最低位开始取每个位组成radix数组；对radix进行计数排序（利用计数排序适用于小范围数的特点）； 动图演示 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.Arrays;class Untitled &#123; public static void main(String[] args) &#123; int[] data = new int[] &#123; 1100, 192, 221, 12, 23 &#125;; print(data); radixSort(data, 10, 4); System.out.println("排序后的数组："); print(data); &#125; public static void radixSort(int[] data, int radix, int d) &#123; // 缓存数组 int[] tmp = new int[data.length]; // buckets用于记录待排序元素的信息 // buckets数组定义了max-min个桶 int[] buckets = new int[radix]; for (int i = 0, rate = 1; i &lt; d; i++) &#123; // 重置count数组，开始统计下一个关键字 Arrays.fill(buckets, 0); // 将data中的元素完全复制到tmp数组中 System.arraycopy(data, 0, tmp, 0, data.length); // 计算每个待排序数据的子关键字 for (int j = 0; j &lt; data.length; j++) &#123; int subKey = (tmp[j] / rate) % radix; buckets[subKey]++; &#125; for (int j = 1; j &lt; radix; j++) &#123; buckets[j] = buckets[j] + buckets[j - 1]; &#125; // 按子关键字对指定的数据进行排序 for (int m = data.length - 1; m &gt;= 0; m--) &#123; int subKey = (tmp[m] / rate) % radix; data[--buckets[subKey]] = tmp[m]; &#125; rate *= radix; &#125; &#125; public static void print(int[] data) &#123; for (int i = 0; i &lt; data.length; i++) &#123; System.out.print(data[i] + "\t"); &#125; System.out.println(); &#125;&#125; 算法分析最佳情况：T(n) = O(n k) 最差情况：T(n) = O(n k) 平均情况：T(n) = O(n * k) 结语至此，八大算法都讲解完成，大家有更好地代码可以在评论区发表，欢迎大家批评指正。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统基本操作]]></title>
    <url>%2F2019%2F07%2F06%2FLinux%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[常考的Linux命令 cd用于切换当前目录，它的参数是要切换到的目录的路径，可以是绝对路径，也可以是相对路径。 cd /root/runoob/ ：绝对路径cd ./runoob/ ：相对路径 ls查看文件与目录的命令 ls -l (也可以直接 ll ) ：列出长数据串，包含文件的属性与权限数据等ls -a ：列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用） grep文本搜索 语法：grep 参数 查找条件 文件名（注：是文件名，目录名下查找不行）主要参数：－i：不区分大小写(只适用于字母字符。）－l：查询多文件时只输出包含匹配字符的文件名。－n：显示匹配行内容及行号。比如我的/opt目录下有文件test1.txtgrep -i “teacher” test1.txt : 查询包含 teacher 文本的所有行并打印在屏幕上grep -l “teacher” test1.txt test2.txt : 在文件test1/test2中查找是否有“teacher”grep teacher *.txt : 显示当前目录下包含“teacher”且以.txt 结尾的文件（grep命令支持正则表达式，如 grep ‘[a-z]\{7\}’ *.txt）ps -ef | grep java：查找指定进程(这里指定java进程)ls -l | grep -i test：把ls -l的输出中包含字母test（不区分大小写）的内容输出 （如果查询的是目录可以使用正则表达式，但是文件不行） find查找 -mtime +n : 列出在n天之前（不含n天本身）被更改过的文件名；-mtime -n : 列出在n天之内（含n天本身）被更改过的文件名；find /root（路径） -mtime 0 ： 在当前目录下查找今天之内有改动的文件find -name 文件名 ：找匹配的文件名在某一文件中查找日志（比方方法login）:可以vi打开日志文件，然后“/login”，enter，按 n 键向下继续搜索； mkdir创建指定的名称的目录 -m, —mode=模式，设定权限&lt;模式&gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask-p, —parents 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录;mkdir test1 ： 创建一个空目录mkdir -p test2/test22 ：递归创建多个目录mkdir -m 777 test3 ：创建权限为777的目录 cp复制文件，还可以把多个文件一次性地复制到一个目录下 cp -a file1 file2 ：连同文件的所有特性把文件file1复制成文件file2cp file1 file2 file3 dir ：把文件file1、file2、file3复制到目录dir中 mv移动文件、目录或更名 mv file1 file2 file3 dir : 把文件file1、file2、file3移动到目录dir中mv file1 file2 : 把文件file1重命名为file2 rm删除文件或目录 -f：就是force的意思，忽略不存在的文件，不会出现警告消息-i：互动模式，在删除前会询问用户是否操作-r：递归删除，最常用于目录删除，它是一个非常危险的参数rm -i file : 删除文件file，在删除之前会询问是否进行该操作rm -fr dir : 强制删除目录dir中的所有文件 ps列出系统中当前运行的进程 a 显示所有用户的所有进程（包括其它用户）-e 显示所有进程,环境变量f 用树形格式来显示进程；ps -ef | grep java ： 找出所有java进程 kill终止指定的进程。需要先使用ps/pidof/pstree/top等工具获取进程PID，然后使用kill命令来杀掉该进程。 kill -9 进程号 ： 彻底杀死某个进程 tar对文件进行打包，默认情况并不会压缩，如果指定了相应的参数，它还会调用相应的压缩程序（如gzip和bzip等）进行压缩和解压。 语法：tar [主选项+辅选项] 文件或者目录使用该命令时，主选项是必须要有的，它告诉tar要做什么事情，辅选项是辅助使用的，可以选用。 主选项： c 创建新的档案文件。如果用户想备份一个目录或是一些文件，就要选择这个选项。相当于打包。x 从档案文件中释放文件。相当于拆包。t 列出档案文件的内容，查看已经备份了哪些文件。**在参数的下达中， c/x/t 仅能存在一个！不可同时存在！因为不可能同时压缩与解压缩。 辅助选项： -z ：是否同时具有 gzip 的属性？亦即是否需要用 gzip 压缩或解压？ 一般格式为xx.tar.gz或xx. tgz-j ：是否同时具有 bzip2 的属性？亦即是否需要用 bzip2 压缩或解压？一般格式为xx.tar.bz2-v ：压缩的过程中显示文件！这个常用-f ：使用档名，请留意，在 f 之后要立即接档名喔！不要再加其他参数！-p ：使用原文件的原来属性（属性不会依据使用者而变）–exclude FILE：在压缩的过程中，不要将 FILE 打包！压缩：tar -jcv -f filename.tar.bz2 filename查询：tar -jtv -f filename.tar.bz2解压：tar -jxv -f filename.tar.bz2 (解压成目录为filename的目录)注：文件名并不定要以后缀tar.bz2结尾，这里主要是为了说明使用的压缩程序为bzip2 chmod改变文件的权限 语法：chmod [options] mode filesoptions：-R 可递归遍历子目录，把修改应到目录下所有文件和子目录who：u 用户 、 g 组 、o 其他 、a 所有用户opcode：+ 增加权限 、 - 删除权限 、= 重新分配权限permission： r 读 、w 写 、 x 执行我们多数用三位八进制数字的形式来表示权限，第一位指定属主的权限，第二位指定组权限，第三位指定其他用户的权限，每位通过4(读)、2(写)、1(执行)三种数值的和来确定权限。如6(4+2)代表有读写权，7(4+2+1)有读、写和执行的权限chmod u+x file ：给file的属主增加执行权限chmod 751 file ：给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限chmod u=rwx,g=rx,o=x file ：上例的另一种形式 tail查阅正在改变的日志文件 语法：tail[必要参数][选择参数][文件]-f 循环读取-n&lt;行数&gt; 显示行数tail -f 20160921.logs ：查看正在改变的日志文件；tail -3000 catalina.out：查看倒数前3000行的数据；tail -3000 catalina.out | grep ‘AA’：查看倒数前3000行包含字母’AA’的数据；ctrl+z 可退出 查看进程pidlsof -i:8080：根据端口查看进程pid: 面试题面试官常问的十个linux问题1. 如何暂停一个正在运行的进程，把其放在后台（不运行）？答案：为了停止正在运行的进程，让其在后台运行，我们可以使用组合键 Ctrl+Z。 2. 什么是安装Linux所需的最小分区数量，以及如何查看系统启动信息？答案：单独一个/root分区足以执行所有的系统任务，但是强烈建议安装Linux时，需要至少三个分区：/root,/boot,/swap。一个IDE硬盘驱动器支持高达63个分区，SCSI硬盘驱动器支持超过15个分区。为了检查启动信息，我们可以使用cat或者dmesg命令，如下所示： #cat /var/log/messages 或者 #dmesg 3. 在你的Linux机器上跟踪系统事件的守护进程名是什么？答案：’syslogd’，它负责跟踪系统信息，并将跟踪日志存储在特定的日志文件里。 4. 在/root分区运行’fsck’命令的最低要求是什么？答案：/root分区必须挂载为只读模式，而不是读写模式 5. 如何分层复制/home目录到另一个目录？答案：Linux的’cpio’命令起到了效果。’cpio’可以分层地复制文件和目录层次结构到另一个位置。 6. 在Linux中，怎样实现日志文件的自动替换？答案：’logrotate’提供日志自动替换功能。 7. 怎样知道Linux中是谁在安排工作？答案：使用’at’命令加上’-l’选项，就可以查出。 8. 如何在不解压tar包的前提下，查看包里的内容？答案：使用’tar -tvf’。选项‘t’(显示内容)，‘v’（详细报告tar处理的文件信息），‘f’（使用档案文件或者设备） 9. 什么是页面错误，它是怎么发生的？答案：当一个程序请求内存中不存在的数据时，就会产生页面错误，导致的结果就是程序停止。 10. 什么是在程序中返回代码？答案：返回代码是shell的特性。返回代码显示了程序的状态，一个成功的程序执行后返回‘0’，&amp;&amp;可以用来决定那个应用程序先执行。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js的安装]]></title>
    <url>%2F2019%2F07%2F05%2Fnode-js%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Node.JS 的安装本文将向大家介绍在window安装Node.js的方法。本安装教程以Node.js v4.4.3 LTS(长期支持版本)版本为例。 Node.js安装包及源码下载地址为：https://nodejs.org/en/download/。 你可以根据不同平台系统选择你需要的Node.js安装包。 Node.js 历史版本下载地址：https://nodejs.org/dist/Window 上安装Node.jsWindows 安装包(.msi) 32 位安装包下载地址 : https://nodejs.org/dist/v4.4.3/node-v4.4.3-x86.msi 64 位安装包下载地址 : https://nodejs.org/dist/v4.4.3/node-v4.4.3-x64.msi 本文实例以 v0.10.26 版本为例，其他版本类似， 安装步骤： 步骤 1 : 双击下载后的安装包 v0.10.26，如下所示： 步骤 2 : 点击以上的Run(运行)，将出现如下界面： 步骤 3 : 勾选接受协议选项，点击 next（下一步） 按钮 : 步骤 4 : Node.js默认安装目录为 “C:\Program Files\nodejs\” , 你可以修改目录，并点击 next（下一步）： 步骤 5 : 点击树形图标来选择你需要的安装模式 , 然后点击下一步 next（下一步） 步骤 6 :点击 Install（安装） 开始安装Node.js。你也可以点击 Back（返回）来修改先前的配置。 然后并点击 next（下一步）： 安装过程： 点击 Finish（完成）按钮退出安装向导。 &lt;/div&gt; 检测PATH环境变量是否配置了Node.js，点击开始=》运行=》输入”cmd” =&gt; 输入命令”path”，输出如下结果： 123456PATH=C:\oraclexe\app\oracle\product\10.2.0\server\bin;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;c:\python32\python;C:\MinGW\bin;C:\Program Files\GTK2-Runtime\lib; C:\Program Files\MySQL\MySQL Server 5.5\bin;C:\Program Files\nodejs\;C:\Users\rg\AppData\Roaming\npm 我们可以看到环境变量中已经包含了C:\Program Files\nodejs\检查Node.js版本 结语至此，node.js安装完成。 参考博客: https://www.simon96.online/2018/11/10/hexo-env/]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建]]></title>
    <url>%2F2019%2F07%2F02%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[如果你和我一样是小白，从来没搭建过博客。那么恭喜你！看完这篇文章，你也可以拥有一个这样的博客啦！ 准备环境搭建本地个人博客]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
