<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小唐人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tangguangzhen.github.io/"/>
  <updated>2019-08-03T02:05:07.026Z</updated>
  <id>https://tangguangzhen.github.io/</id>
  
  <author>
    <name>tgz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网易2019校招笔试算法题（Java）</title>
    <link href="https://tangguangzhen.github.io/2019/08/03/%E7%BD%91%E6%98%932019%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%88Java%EF%BC%89/"/>
    <id>https://tangguangzhen.github.io/2019/08/03/网易2019校招笔试算法题（Java）/</id>
    <published>2019-08-03T01:07:27.000Z</published>
    <updated>2019-08-03T02:05:07.026Z</updated>
    
    <content type="html"><![CDATA[<p>最近在准备秋招的笔试，做了一下网易的秋招笔试题（Java）。话不多说，题目、代码如下。</p><a id="more"></a><h1 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小易觉得高数课太无聊了，决定睡觉。不过他对课上的一些内容挺感兴趣，所以希望老师讲到有趣的地方的时候叫醒他一下。你知道了小易对一堂课每分钟知识点的感兴趣程度，并以分数量化，以及他在这堂课上每分钟是否会睡着，你可以叫醒他一次，这会使得他在接下来的k分钟内保持清醒。你需要选择一种方案最大化小易这堂课听到的知识点分值。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行n，k, (1&lt;= n, k&lt;= $$10^5$$)，表示这堂课持续多少分钟，以及叫醒小易一次使他能够保持清醒的时间。<br>第二行 n个数，$$a_{1},a_{2},…, a_{n} (1&lt;= a_{i} &lt;= 10^4)$$，表示小易对每分钟知识点的感兴趣评分。<br>第三行 n个数，t_{1}, t_{2}, …, t_{n}，表示每分钟小易是否清醒，1表示清醒。</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>小易这堂课听到的知识点的最大兴趣值。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>输入<br>6 3<br>1 3 5 2 5 4<br>1 1 0 1 0 0<br>输出<br>16</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在准备秋招的笔试，做了一下网易的秋招笔试题（Java）。话不多说，题目、代码如下。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://tangguangzhen.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://tangguangzhen.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="笔试题" scheme="https://tangguangzhen.github.io/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>多线程笔试题</title>
    <link href="https://tangguangzhen.github.io/2019/07/31/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <id>https://tangguangzhen.github.io/2019/07/31/多线程笔试题/</id>
    <published>2019-07-31T14:07:13.000Z</published>
    <updated>2019-07-31T14:17:26.183Z</updated>
    
    <content type="html"><![CDATA[<p>同程艺龙JAVA工程师多线程笔试题</p><a id="more"></a><h1 id="笔试题题目"><a href="#笔试题题目" class="headerlink" title="笔试题题目"></a>笔试题题目</h1><p>问题描述:<br>设计三个线程，三个线程并行执行，要求分别在控制台输入数据后面拼接”_A”，”_B”，”_C”，并且需要保证线程1，线程2，线程3按顺序执行，即线程1执行完成后，再执行线程2，线程2执行完成后再执行线程3<br>1.线程运行逻辑：在输入参数中拼接字符串，1号线程拼接”_A”，2号线程拱接_B”， 3号线程拼接”_C”<br>2.程序运行时需要同时启动三个钱程<br>3.线程运行时，需要按照指定顺序运行，1号线程(执行完成) -&gt;2号钱程(执行完威) -&gt;3号线(执行完成)<br>输入描述：<br>字符串输入<br>输入使用Sanner sc = new Sanner(System.in) 获取输入数据<br>输出描述:<br>运算结果输出<br>程序运行结果使用System.out.pintin()输出到控制台<br>输入样例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br></pre></td></tr></table></figure><p>输出样例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello_A_B_C</span><br></pre></td></tr></table></figure><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> String str;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkersA</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        str += <span class="string">"_A"</span>;</span><br><span class="line">            System.out.println(<span class="string">"正在运行A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkersB</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        str += <span class="string">"_B"</span>;</span><br><span class="line">            System.out.println(<span class="string">"正在运行B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkersC</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        str += <span class="string">"_C"</span>;</span><br><span class="line">            System.out.println(<span class="string">"正在运行C"</span>);</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    str = sc.nextLine();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> WorkersA());</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.join();<span class="comment">//使得t.join()中的t优先执行，当t执行完后才会执行其他线程。能够使得线程之间的并行执行变成串行执行。</span></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> WorkersB());</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread2.join();</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> WorkersC());</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread3.join();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;同程艺龙JAVA工程师多线程笔试题&lt;/p&gt;
    
    </summary>
    
      <category term="多线程" scheme="https://tangguangzhen.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="https://tangguangzhen.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://tangguangzhen.github.io/2019/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://tangguangzhen.github.io/2019/07/10/计算机网络/</id>
    <published>2019-07-10T03:29:41.000Z</published>
    <updated>2019-07-10T03:29:41.466Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://tangguangzhen.github.io/2019/07/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://tangguangzhen.github.io/2019/07/08/操作系统/</id>
    <published>2019-07-08T09:28:34.000Z</published>
    <updated>2019-07-08T11:52:02.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p>区别联系：<br>1.进程是系统资源分配的最小单位，线程是程序执行的最小单位；<br>2.进程使用独立的数据空间，线程共享进程的数据空间。</p><h1 id="线程调度算法"><a href="#线程调度算法" class="headerlink" title="线程调度算法"></a>线程调度算法</h1><p>1.时间片轮转调度<br>2.先来先服务调度<br>3.优先级调度<br>4.多级反馈队列调度<br>5.高响应比优先调度</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;进程与线程&quot;&gt;&lt;a href=&quot;#进程与线程&quot; class=&quot;headerlink&quot; title=&quot;进程与线程&quot;&gt;&lt;/a&gt;进程与线程&lt;/h1&gt;&lt;p&gt;区别联系：&lt;br&gt;1.进程是系统资源分配的最小单位，线程是程序执行的最小单位；&lt;br&gt;2.进程使用独立的数据空间，线
      
    
    </summary>
    
      <category term="操作系统" scheme="https://tangguangzhen.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://tangguangzhen.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Spring入门（1）</title>
    <link href="https://tangguangzhen.github.io/2019/07/07/Spring%E5%85%A5%E9%97%A8%EF%BC%881%EF%BC%89/"/>
    <id>https://tangguangzhen.github.io/2019/07/07/Spring入门（1）/</id>
    <published>2019-07-07T07:26:19.000Z</published>
    <updated>2019-07-11T07:41:54.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring的概述"><a href="#Spring的概述" class="headerlink" title="Spring的概述"></a>Spring的概述</h1><a id="more"></a><h2 id="什么是Spring？"><a href="#什么是Spring？" class="headerlink" title="什么是Spring？"></a>什么是Spring？</h2><p>Spring 是一个开源框架<br>Spring 为简化企业级应用开发而生. 使用Spring可以使简单的JavaBean实现以前只有EJB才能实现的功能<br>Spring 是JavaSE/EE的一站式框架</p><h2 id="Spring的概述-Spring的优点"><a href="#Spring的概述-Spring的优点" class="headerlink" title="Spring的概述-Spring的优点"></a>Spring的概述-Spring的优点</h2><p>• 方便解耦，简化开发<br>– Spring就是一个大工厂，可以将所有对象创建和依赖关系维护，交给Spring<br>管理<br>• AOP编程的支持<br>– Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控<br>等功能<br>• 声明式事务的支持<br>– 只需要通过配置就可以完成对事务的管理，而无需手动编程</p><p>• 方便程序的测试<br>– Spring对Junit4支持，可以通过注解方便的测试Spring程序<br>• 方便集成各种优秀框架<br>– Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、<br>Hibernate、 MyBatis等）的直接支持<br>• 降低JavaEE API的使用难度<br>– Spring 对JavaEE开发中非常难用的一些API（JDBC、 JavaMail、远程调用<br>等），都提供了封装，使这些API应用难度大大降低</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring的概述&quot;&gt;&lt;a href=&quot;#Spring的概述&quot; class=&quot;headerlink&quot; title=&quot;Spring的概述&quot;&gt;&lt;/a&gt;Spring的概述&lt;/h1&gt;
    
    </summary>
    
      <category term="Spring" scheme="https://tangguangzhen.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="https://tangguangzhen.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>八大经典排序算法</title>
    <link href="https://tangguangzhen.github.io/2019/07/06/%E5%85%AB%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://tangguangzhen.github.io/2019/07/06/八大经典排序算法/</id>
    <published>2019-07-06T14:56:46.000Z</published>
    <updated>2019-07-09T02:49:16.538Z</updated>
    
    <content type="html"><![CDATA[<p>八大经典排序算法（JAVA版）：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、基数排序</p><a id="more"></a><h1 id="排序算法基础知识"><a href="#排序算法基础知识" class="headerlink" title="排序算法基础知识"></a>排序算法基础知识</h1><h2 id="术语说明"><a href="#术语说明" class="headerlink" title="术语说明"></a>术语说明</h2><p>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；<br>不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；<br>内排序：所有排序操作都在内存中完成；<br>外排序：因数据量太大，故把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；<br>时间复杂度： 一个算法执行所耗费的时间。<br>空间复杂度：运行完一个程序所需内存的大小。</p><h2 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h2><p><img src="sort01.jpg" alt="image"><br>图片名词解释：<br>n: 数据规模<br>k: “桶”的个数<br>In-place: 占用常数内存，不占用额外内存<br>Out-place: 占用额外内存</p><h2 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h2><p><img src="sort02.jpg" alt="image"><br>比较和非比较的区别<br>常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。<br>在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。<br>比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。<br>计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr之前有多少个元素，则唯一确定了arr在排序后数组中的位置。<br>非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。<br>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</p><h1 id="八大排序算法"><a href="#八大排序算法" class="headerlink" title="八大排序算法"></a>八大排序算法</h1><h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>比较相邻的元素。如果第一个比第二个大，就交换它们两个；<br>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；<br>针对所有的元素重复以上的步骤，除了最后一个；<br>重复步骤1~3，直到排序完成。</p><h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="bubble_sort.gif" alt="image"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 冒泡排序 的时间复杂度 O(n^2), 自己写出</span></span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>; <span class="comment">// 临时变量</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 标识变量，表示是否进行过交换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果前面的数比后面的数大，则交换</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123; <span class="comment">// 在一趟排序中，一次交换都没有发生过</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>; <span class="comment">// 重置flag!!!, 进行下次判断</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>最佳情况：T(n) = O(n)   最差情况：T(n) = O(n2)   平均情况：T(n) = O(n2)</p><h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。<br>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：<br>初始状态：无序区为R[1..n]，有序区为空；<br>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；<br>n-1趟结束，数组有序化了。</p><h3 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="selection_sort.gif" alt="image"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//选择排序时间复杂度是 O(n^2)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">int</span> min = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (min &gt; arr[j]) &#123; <span class="comment">// 说明假定的最小值，并不是最小</span></span><br><span class="line">                    min = arr[j]; <span class="comment">// 重置min</span></span><br><span class="line">                    minIndex = j; <span class="comment">// 重置minIndex</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将最小值，放在arr[0], 即交换</span></span><br><span class="line">            <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">                arr[minIndex] = arr[i];</span><br><span class="line">                arr[i] = min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><p>最佳情况：T(n) = O(n2)  最差情况：T(n) = O(n2)  平均情况：T(n) = O(n2)</p><h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h3 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h3><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：<br>步骤1：从第一个元素开始，该元素可以认为已经被排序；<br>步骤2：取出下一个元素，在已经排序的元素序列中从后向前扫描；<br>步骤3：如果该元素（已排序）大于新元素，将该元素移到下一位置；<br>步骤4：重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；<br>步骤5：将新元素插入到该位置后；<br>重复步骤2~5。</p><h3 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="Insertion_Sort.gif" alt="image"></p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> insertVal = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> insertIndex = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//使用for循环来把代码简化</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">           <span class="comment">//定义待插入的数</span></span><br><span class="line">           insertVal = arr[i];</span><br><span class="line">           insertIndex = i - <span class="number">1</span>; <span class="comment">// 即arr[1]的前面这个数的下标</span></span><br><span class="line">           <span class="comment">// 给insertVal 找到插入的位置</span></span><br><span class="line">           <span class="comment">// 说明</span></span><br><span class="line">           <span class="comment">// 1. insertIndex &gt;= 0 保证在给insertVal 找插入位置，不越界</span></span><br><span class="line">           <span class="comment">// 2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置</span></span><br><span class="line">           <span class="comment">// 3. 就需要将 arr[insertIndex] 后移</span></span><br><span class="line">           <span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span><br><span class="line">               arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];</span><br><span class="line">               insertIndex--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 当退出while循环时，说明插入的位置找到, insertIndex + 1</span></span><br><span class="line">           <span class="comment">// 举例：理解不了，我们一会 debug</span></span><br><span class="line">           <span class="comment">//这里我们判断是否需要赋值</span></span><br><span class="line">           <span class="keyword">if</span>(insertIndex + <span class="number">1</span> != i) &#123;</span><br><span class="line">               arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><p>最佳情况：T(n) = O(n)   最坏情况：T(n) = O(n2)   平均情况：T(n) = O(n2)</p><h2 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h2><p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。<br>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><h3 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h3><p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。<br>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：<br>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；<br>按增量序列个数k，对序列进行k 趟排序；<br>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><h3 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="Shell_Sort.jpg" alt="image"></p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// 根据前面的逐步分析，使用循环处理</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">               <span class="comment">// 遍历各组中所有的元素(共gap组，每组有个元素), 步长gap</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = i - gap; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">                   <span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line">                   <span class="keyword">if</span> (arr[j] &gt; arr[j + gap]) &#123;</span><br><span class="line">                       temp = arr[j];</span><br><span class="line">                       arr[j] = arr[j + gap];</span><br><span class="line">                       arr[j + gap] = temp;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//对交换式的希尔排序进行优化-&gt;移位法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 增量gap, 并逐步的缩小增量</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">           <span class="comment">// 从第gap个元素，逐个对其所在的组进行直接插入排序</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">               <span class="keyword">int</span> j = i;</span><br><span class="line">               <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">               <span class="keyword">if</span> (arr[j] &lt; arr[j - gap]) &#123;</span><br><span class="line">                   <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j - gap]) &#123;</span><br><span class="line">                       <span class="comment">//移动</span></span><br><span class="line">                       arr[j] = arr[j-gap];</span><br><span class="line">                       j -= gap;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//当退出while后，就给temp找到插入的位置</span></span><br><span class="line">                   arr[j] = temp;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><p>最佳情况：T(n) = O(nlog2 n)  最坏情况：T(n) = O(nlog2 n)  平均情况：T(n) =O(nlog2n)　</p><h2 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h2><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。<br>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><h3 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h3><p>把长度为n的输入序列分成两个长度为n/2的子序列；<br>对这两个子序列分别采用归并排序；<br>将两个排序好的子序列合并成一个最终的排序序列。</p><h3 id="动图演示-4"><a href="#动图演示-4" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="Merge_Sort.gif" alt="image"></p><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**归并排序</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] MergeSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">     <span class="keyword">if</span> (array.length &lt; <span class="number">2</span>)</span><br><span class="line">         <span class="keyword">return</span> array;</span><br><span class="line">     <span class="keyword">int</span> mid = array.length / <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">int</span>[] left = Arrays.copyOfRange(array, <span class="number">0</span>, mid);</span><br><span class="line">     <span class="keyword">int</span>[] right = Arrays.copyOfRange(array, mid, array.length);</span><br><span class="line">     <span class="keyword">return</span> merge (MergeSort(left), MergeSort (right));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 归并排序-将两段排序好的数组结合成一个排序数组</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> 1eft</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] left, <span class="keyword">int</span>[] right) &#123;</span><br><span class="line">     <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[left.length + right. length];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>, i=<span class="number">0</span>, j=<span class="number">0</span>; index &lt; result.length; index++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (i&gt;=left.length)</span><br><span class="line">             result[index] = right[j++];</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (j &gt;= right.length)</span><br><span class="line">             result[index] = left[i++];</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (left[i] &gt; right[j])</span><br><span class="line">             result[index] = right[j++];</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             result[index] = left[i++];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h3><p>最佳情况：T(n) = O(n)  最差情况：T(n) = O(nlogn)  平均情况：T(n) = O(nlogn)</p><h2 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h2><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h3 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h3><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：<br>从数列中挑出一个元素，称为 “基准”（pivot）；<br>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p><h3 id="动图演示-5"><a href="#动图演示-5" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="Quick_Sort.gif" alt="image"></p><h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = partition(arr,left,right);</span><br><span class="line">        quickSort(arr, left, mid);</span><br><span class="line">        quickSort(arr, mid+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin_num = arr[left], i = left, j = right;</span><br><span class="line">    <span class="keyword">while</span>(i != j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[j] &gt;= begin_num &amp;&amp; i!=j)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        <span class="keyword">while</span>(arr[i] &lt; begin_num &amp;&amp; i!=j)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = begin_num;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h3><p>最佳情况：T(n) = O(nlogn)   最差情况：T(n) = O(n2)   平均情况：T(n) = O(nlogn)</p><h2 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h3 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h3><p>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；<br>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</p><h3 id="动图演示-6"><a href="#动图演示-6" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="Heap_Sort01.gif" alt="image"><br><img src="Heap_Sort02.gif" alt="image"></p><h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 构建大顶堆 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] data,<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp, j;</span><br><span class="line">temp = data[i];</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">2</span>*i+<span class="number">1</span>; j &lt; len; j = <span class="number">2</span>*j+<span class="number">1</span>) &#123; <span class="comment">//j为初始化为节点i的左孩子，沿节点较大的子节点向下调整</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (j &lt; len &amp;&amp; data[j] &lt; data[j + <span class="number">1</span>]) &#123;<span class="comment">//取节点较大的子节点的下标</span></span><br><span class="line">++j;  <span class="comment">//如果节点的右孩子&gt;左孩子，则取右孩子节点的下标       </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (temp &gt;= data[j]) &#123; <span class="comment">//根节点 &gt;=左右子女中关键字较大者，调整结束</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;   <span class="comment">//根节点 &lt;左右子女中关键字较大者</span></span><br><span class="line">               data[i] = data[j];  <span class="comment">//将左右子结点中较大值data[j]调整到双亲节点上</span></span><br><span class="line">               i = j; <span class="comment">//【关键】修改i值，以便继续向下调整</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">data[i] = temp;<span class="comment">//被调整的结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O（n^2）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">//从最后一个节点array.length-1的父节点（array.length-1-1）/2开始，直到根节点0，反复调整堆</span></span><br><span class="line"><span class="keyword">for</span> (i = (data.length-<span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">//构建一个大顶堆</span></span><br><span class="line">adjustHeap(data, i, data.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = data.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"> <span class="comment">//将堆顶记录和当前未经排序子序列的最后一个记录交换</span></span><br><span class="line">    <span class="keyword">int</span> temp = data[<span class="number">0</span>];</span><br><span class="line">data[<span class="number">0</span>] = data[i];</span><br><span class="line">data[i] = temp;</span><br><span class="line">adjustHeap(data, <span class="number">0</span>, i - <span class="number">1</span>); <span class="comment">//将a中前i-1个记录重新调整为大顶堆</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        </span><br><span class="line">System.out.println(<span class="string">"交换之前："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:arr)&#123;</span><br><span class="line">            System.out.print(num+<span class="string">" "</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    heapSort(arr);</span><br><span class="line">    System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"交换后："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:arr)&#123;</span><br><span class="line">            System.out.print(num+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h3><p>最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn)</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；<br>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p><h3 id="算法描述-7"><a href="#算法描述-7" class="headerlink" title="算法描述"></a>算法描述</h3><p>取得数组中的最大数，并取得位数；<br>arr为原始数组，从最低位开始取每个位组成radix数组；<br>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p><h3 id="动图演示-7"><a href="#动图演示-7" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="Radix_Sort.gif" alt="image"></p><h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Untitled</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1100</span>, <span class="number">192</span>, <span class="number">221</span>, <span class="number">12</span>, <span class="number">23</span> &#125;;</span><br><span class="line">print(data);</span><br><span class="line">radixSort(data, <span class="number">10</span>, <span class="number">4</span>);</span><br><span class="line">System.out.println(<span class="string">"排序后的数组："</span>);</span><br><span class="line">print(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> radix, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 缓存数组</span></span><br><span class="line"><span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[data.length];</span><br><span class="line"><span class="comment">// buckets用于记录待排序元素的信息</span></span><br><span class="line"><span class="comment">// buckets数组定义了max-min个桶</span></span><br><span class="line"><span class="keyword">int</span>[] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[radix];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, rate = <span class="number">1</span>; i &lt; d; i++) &#123;</span><br><span class="line"><span class="comment">// 重置count数组，开始统计下一个关键字</span></span><br><span class="line">Arrays.fill(buckets, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 将data中的元素完全复制到tmp数组中</span></span><br><span class="line">System.arraycopy(data, <span class="number">0</span>, tmp, <span class="number">0</span>, data.length);</span><br><span class="line"><span class="comment">// 计算每个待排序数据的子关键字</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; data.length; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> subKey = (tmp[j] / rate) % radix;</span><br><span class="line">buckets[subKey]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; radix; j++) &#123;</span><br><span class="line">buckets[j] = buckets[j] + buckets[j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按子关键字对指定的数据进行排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = data.length - <span class="number">1</span>; m &gt;= <span class="number">0</span>; m--) &#123;</span><br><span class="line"><span class="keyword">int</span> subKey = (tmp[m] / rate) % radix;</span><br><span class="line">data[--buckets[subKey]] = tmp[m];</span><br><span class="line">&#125;</span><br><span class="line">rate *= radix;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">System.out.print(data[i] + <span class="string">"\t"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-7"><a href="#算法分析-7" class="headerlink" title="算法分析"></a>算法分析</h3><p>最佳情况：T(n) = O(n * k)   最差情况：T(n) = O(n * k)   平均情况：T(n) = O(n * k)</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>至此，八大算法都讲解完成，大家有更好地代码可以在评论区发表，欢迎大家批评指正。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;八大经典排序算法（JAVA版）：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、基数排序&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://tangguangzhen.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://tangguangzhen.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统基本操作</title>
    <link href="https://tangguangzhen.github.io/2019/07/06/Linux%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>https://tangguangzhen.github.io/2019/07/06/Linux系统基本操作/</id>
    <published>2019-07-06T07:08:55.000Z</published>
    <updated>2019-07-07T06:14:43.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常考的Linux命令"><a href="#常考的Linux命令" class="headerlink" title="常考的Linux命令"></a>常考的Linux命令</h1><a id="more"></a><h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><p>用于切换当前目录，它的参数是要切换到的目录的路径，可以是绝对路径，也可以是相对路径。</p><blockquote><p><strong>cd /root/runoob/</strong> ：绝对路径<br><strong>cd ./runoob/</strong> ：相对路径 </p></blockquote><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p>查看文件与目录的命令</p><blockquote><p><strong>ls -l</strong> (也可以直接 ll ) ：列出长数据串，包含文件的属性与权限数据等<br><strong>ls -a</strong> ：列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用） </p></blockquote><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>文本搜索 </p><blockquote><p>语法：grep 参数 查找条件 文件名（注：是文件名，目录名下查找不行）<br>主要参数：<br><strong>－i</strong>：不区分大小写(只适用于字母字符。）<br><strong>－l</strong>：查询多文件时只输出包含匹配字符的文件名。<br><strong>－n</strong>：显示匹配行内容及行号。<br>比如我的/opt目录下有文件test1.txt<br><strong>grep -i “teacher” test1.txt</strong> : 查询包含 teacher 文本的所有行并打印在屏幕上<br><strong>grep -l “teacher” test1.txt test2.txt</strong> : 在文件test1/test2中查找是否有“teacher”<br><strong>grep teacher *.txt</strong> : 显示当前目录下包含“teacher”且以.txt 结尾的文件（grep命令支持正则表达式，如  <strong>grep ‘[a-z]{7}‘ *.txt）</strong><br><strong>ps -ef | grep java</strong>：查找指定进程(这里指定java进程)<br><strong>ls -l | grep -i test</strong>：把ls -l的输出中包含字母test（不区分大小写）的内容输出 （如果查询的是目录可以使用正则表达式，但是文件不行） </p></blockquote><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>查找</p><blockquote><p><strong>-mtime +n</strong> : 列出在n天之前（不含n天本身）被更改过的文件名；<br><strong>-mtime -n</strong> : 列出在n天之内（含n天本身）被更改过的文件名；<br><strong>find /root（路径） -mtime 0</strong> ： 在当前目录下查找今天之内有改动的文件<br><strong>find -name 文件名</strong> ：找匹配的文件名<br>在某一文件中查找日志（比方方法login）:可以vi打开日志文件，然后“/login”，enter，按 n 键向下继续搜索； </p></blockquote><h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><p>创建指定的名称的目录</p><blockquote><p><strong>-m</strong>, –mode=模式，设定权限&lt;模式&gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask<br><strong>-p</strong>, –parents  可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录;<br><strong>mkdir test1</strong> ： 创建一个空目录<br><strong>mkdir -p test2/test22</strong> ：递归创建多个目录<br><strong>mkdir -m 777 test3</strong> ：创建权限为777的目录  </p></blockquote><h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><p>复制文件，还可以把多个文件一次性地复制到一个目录下</p><blockquote><p><strong>cp -a file1 file2</strong> ：连同文件的所有特性把文件file1复制成文件file2<br><strong>cp file1 file2 file3 dir</strong> ：把文件file1、file2、file3复制到目录dir中   </p></blockquote><h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><p>移动文件、目录或更名</p><blockquote><p><strong>mv file1 file2 file3 dir</strong> : 把文件file1、file2、file3移动到目录dir中<br><strong>mv file1 file2</strong> : 把文件file1重命名为file2   </p></blockquote><h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p>删除文件或目录</p><blockquote><p><strong>-f</strong>：就是force的意思，忽略不存在的文件，不会出现警告消息<br><strong>-i</strong>：互动模式，在删除前会询问用户是否操作<br><strong>-r</strong>：递归删除，最常用于目录删除，它是一个非常危险的参数<br><strong>rm -i file</strong> : 删除文件file，在删除之前会询问是否进行该操作<br><strong>rm -fr dir</strong> : 强制删除目录dir中的所有文件   </p></blockquote><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>列出系统中当前运行的进程</p><blockquote><p><strong>a</strong> 显示所有用户的所有进程（包括其它用户）<br><strong>-e</strong> 显示所有进程,环境变量<br><strong>f</strong> 用树形格式来显示进程；<br><strong>ps -ef | grep java</strong> ： 找出所有java进程 </p></blockquote><h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><p>终止指定的进程。需要先使用ps/pidof/pstree/top等工具获取进程PID，然后使用kill命令来杀掉该进程。</p><blockquote><p><strong>kill -9 进程号</strong> ： 彻底杀死某个进程 </p></blockquote><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p>对文件进行打包，默认情况并不会压缩，如果指定了相应的参数，它还会调用相应的压缩程序（如gzip和bzip等）进行压缩和解压。 </p><blockquote><p>语法：<strong>tar [主选项+辅选项] 文件或者目录</strong><br>使用该命令时，主选项是必须要有的，它告诉tar要做什么事情，辅选项是辅助使用的，可以选用。 　</p></blockquote><p>主选项：</p><blockquote><p><strong>c</strong> 创建新的档案文件。如果用户想备份一个目录或是一些文件，就要选择这个选项。相当于打包。<br><strong>x</strong> 从档案文件中释放文件。相当于拆包。<br><strong>t</strong> 列出档案文件的内容，查看已经备份了哪些文件。<br>**在参数的下达中， c/x/t 仅能存在一个！不可同时存在！因为不可能同时压缩与解压缩。</p></blockquote><p>辅助选项：</p><blockquote><p><strong>-z</strong> ：是否同时具有 gzip 的属性？亦即是否需要用 gzip 压缩或解压？ 一般格式为xx.tar.gz或xx. tgz<br><strong>-j</strong> ：是否同时具有 bzip2 的属性？亦即是否需要用 bzip2 压缩或解压？一般格式为xx.tar.bz2<br><strong>-v</strong> ：压缩的过程中显示文件！这个常用<br><strong>-f</strong> ：使用档名，请留意，在 f 之后要立即接档名喔！不要再加其他参数！<br><strong>-p</strong> ：使用原文件的原来属性（属性不会依据使用者而变）<br><strong>–exclude FILE</strong>：在压缩的过程中，不要将 FILE 打包！<br>压缩：tar -jcv -f filename.tar.bz2 filename<br>查询：tar -jtv -f filename.tar.bz2<br>解压：tar -jxv -f filename.tar.bz2 (解压成目录为filename的目录)<br>注：文件名并不定要以后缀tar.bz2结尾，这里主要是为了说明使用的压缩程序为bzip2 </p></blockquote><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><p>改变文件的权限 </p><blockquote><p>语法：chmod [options] mode files<br>options：-R 可递归遍历子目录，把修改应到目录下所有文件和子目录<br>who：u 用户 、 g 组 、o 其他 、a 所有用户<br>opcode：+ 增加权限 、 - 删除权限 、= 重新分配权限<br>permission： r 读 、w 写 、 x 执行<br>我们多数用三位八进制数字的形式来表示权限，第一位指定属主的权限，第二位指定组权限，第三位指定其他用户的权限，每位通过4(读)、2(写)、1(执行)三种数值的和来确定权限。如6(4+2)代表有读写权，7(4+2+1)有读、写和执行的权限<br>chmod u+x file ：给file的属主增加执行权限<br>chmod 751 file ：给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限<br>chmod u=rwx,g=rx,o=x file ：上例的另一种形式 </p></blockquote><h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><p>查阅正在改变的日志文件 </p><blockquote><p>语法：tail[必要参数][选择参数][文件]<br><strong>-f</strong> 循环读取<br><strong>-n&lt;行数&gt;</strong> 显示行数<br><strong>tail -f 20160921.logs</strong> ：查看正在改变的日志文件；<br><strong>tail -3000 catalina.out</strong>：查看倒数前3000行的数据；<br><strong>tail -3000 catalina.out | grep ‘AA’</strong>：查看倒数前3000行包含字母’AA’的数据；<br><strong>ctrl+z</strong> 可退出 </p></blockquote><h2 id="查看进程pid"><a href="#查看进程pid" class="headerlink" title="查看进程pid"></a>查看进程pid</h2><p>lsof -i:8080：根据端口查看进程pid:</p><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><p>面试官常问的十个linux问题<br><strong>1. 如何暂停一个正在运行的进程，把其放在后台（不运行）？</strong><br>答案：为了停止正在运行的进程，让其在后台运行，我们可以使用组合键 Ctrl+Z。</p><p><strong>2. 什么是安装Linux所需的最小分区数量，以及如何查看系统启动信息？</strong><br>答案：单独一个/root分区足以执行所有的系统任务，但是强烈建议安装Linux时，需要至少三个分区：/root,/boot,/swap。一个IDE硬盘驱动器支持高达63个分区，SCSI硬盘驱动器支持超过15个分区。<br>为了检查启动信息，我们可以使用cat或者dmesg命令，如下所示：</p><pre><code class="java">#cat /var/log/messages</code></pre><p>或者</p><pre><code class="java">#dmesg</code></pre><p><strong>3. 在你的Linux机器上跟踪系统事件的守护进程名是什么？</strong><br>答案：’syslogd’，它负责跟踪系统信息，并将跟踪日志存储在特定的日志文件里。</p><p><strong>4. 在/root分区运行’fsck’命令的最低要求是什么？</strong><br>答案：/root分区必须挂载为只读模式，而不是读写模式</p><p><strong>5. 如何分层复制/home目录到另一个目录？</strong><br>答案：Linux的’cpio’命令起到了效果。’cpio’可以分层地复制文件和目录层次结构到另一个位置。</p><p><strong>6. 在Linux中，怎样实现日志文件的自动替换？</strong><br>答案：’logrotate’提供日志自动替换功能。</p><p><strong>7. 怎样知道Linux中是谁在安排工作？</strong><br>答案：使用’at’命令加上’-l’选项，就可以查出。</p><p><strong>8. 如何在不解压tar包的前提下，查看包里的内容？</strong><br>答案：使用’tar -tvf’。选项‘t’(显示内容)，‘v’（详细报告tar处理的文件信息），‘f’（使用档案文件或者设备）</p><p><strong>9. 什么是页面错误，它是怎么发生的？</strong><br>答案：当一个程序请求内存中不存在的数据时，就会产生页面错误，导致的结果就是程序停止。</p><p><strong>10. 什么是在程序中返回代码？</strong><br>答案：返回代码是shell的特性。返回代码显示了程序的状态，一个成功的程序执行后返回‘0’，&amp;&amp;可以用来决定那个应用程序先执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常考的Linux命令&quot;&gt;&lt;a href=&quot;#常考的Linux命令&quot; class=&quot;headerlink&quot; title=&quot;常考的Linux命令&quot;&gt;&lt;/a&gt;常考的Linux命令&lt;/h1&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://tangguangzhen.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://tangguangzhen.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>node.js的安装</title>
    <link href="https://tangguangzhen.github.io/2019/07/05/node-js%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <id>https://tangguangzhen.github.io/2019/07/05/node-js的安装/</id>
    <published>2019-07-05T07:40:22.000Z</published>
    <updated>2019-07-05T12:16:13.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node-JS-的安装"><a href="#Node-JS-的安装" class="headerlink" title="Node.JS 的安装"></a>Node.JS 的安装</h1><p>本文将向大家介绍在window安装Node.js的方法。</p><a id="more"></a><p>本安装教程以Node.js v4.4.3 LTS(长期支持版本)版本为例。</p><p>Node.js安装包及源码下载地址为：<a href="https://nodejs.org/en/download/。" target="_blank" rel="noopener">https://nodejs.org/en/download/。</a></p><p><img src="01.jpg" alt="image"></p><p>你可以根据不同平台系统选择你需要的Node.js安装包。</p><h2 id="Node-js-历史版本下载地址：https-nodejs-org-dist"><a href="#Node-js-历史版本下载地址：https-nodejs-org-dist" class="headerlink" title="Node.js 历史版本下载地址：https://nodejs.org/dist/"></a>Node.js 历史版本下载地址：<a href="https://nodejs.org/dist/" target="_blank" rel="noopener">https://nodejs.org/dist/</a></h2><h2 id="Window-上安装Node-js"><a href="#Window-上安装Node-js" class="headerlink" title="Window 上安装Node.js"></a>Window 上安装Node.js</h2><p>Windows 安装包(.msi)</p><p>32 位安装包下载地址 : <a href="https://nodejs.org/dist/v4.4.3/node-v4.4.3-x86.msi" target="_blank" rel="noopener">https://nodejs.org/dist/v4.4.3/node-v4.4.3-x86.msi</a></p><p>64 位安装包下载地址 : <a href="https://nodejs.org/dist/v4.4.3/node-v4.4.3-x64.msi" target="_blank" rel="noopener">https://nodejs.org/dist/v4.4.3/node-v4.4.3-x64.msi</a></p><p>本文实例以 v0.10.26 版本为例，其他版本类似， 安装步骤：</p><p>步骤 1 : 双击下载后的安装包 v0.10.26，如下所示：</p><p><img src="02.png" alt="image"></p><p>步骤 2 : 点击以上的Run(运行)，将出现如下界面：</p><p><img src="03.png" alt="image"></p><p>步骤 3 : 勾选接受协议选项，点击 next（下一步） 按钮 :</p><p><img src="04.png" alt="image"></p><p>步骤 4 : Node.js默认安装目录为 “C:\Program Files\nodejs\” , 你可以修改目录，并点击 next（下一步）：</p><p><img src="05.png" alt="image"></p><p>步骤 5 : 点击树形图标来选择你需要的安装模式 , 然后点击下一步 next（下一步）</p><p><img src="06.png" alt="image"></p><p>步骤 6 :点击 Install（安装） 开始安装Node.js。你也可以点击 Back（返回）来修改先前的配置。 然后并点击 next（下一步）：</p><p><img src="07.png" alt="image"></p><p>安装过程：</p><p><img src="08.png" alt="image"></p><p>点击 Finish（完成）按钮退出安装向导。</p><p><img src="09.png" alt="image"></p><p>检测PATH环境变量是否配置了Node.js，点击开始=》运行=》输入”cmd” =&gt; 输入命令”path”，输出如下结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PATH=C:\oraclexe\app\oracle\product\<span class="number">10.2</span>.0\server\bin;C:\Windows\system32;</span><br><span class="line">C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;</span><br><span class="line">c:\python32\python;C:\MinGW\bin;C:\Program Files\GTK2-Runtime\lib;</span><br><span class="line"></span><br><span class="line">C:\Program Files\MySQL\MySQL Server <span class="number">5.5</span>\bin;C:\Program Files\nodejs\;</span><br><span class="line">C:\Users\rg\AppData\Roaming\npm</span><br></pre></td></tr></table></figure><p>我们可以看到环境变量中已经包含了C:\Program Files\nodejs<br>检查Node.js版本<br><img src="10.png" alt="image"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>至此，node.js安装完成。</p><p>参考博客: <a href="https://www.simon96.online/2018/11/10/hexo-env/" target="_blank" rel="noopener">https://www.simon96.online/2018/11/10/hexo-env/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Node-JS-的安装&quot;&gt;&lt;a href=&quot;#Node-JS-的安装&quot; class=&quot;headerlink&quot; title=&quot;Node.JS 的安装&quot;&gt;&lt;/a&gt;Node.JS 的安装&lt;/h1&gt;&lt;p&gt;本文将向大家介绍在window安装Node.js的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="node.js" scheme="https://tangguangzhen.github.io/categories/node-js/"/>
    
    
      <category term="node.js" scheme="https://tangguangzhen.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客搭建</title>
    <link href="https://tangguangzhen.github.io/2019/07/02/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>https://tangguangzhen.github.io/2019/07/02/Hexo博客搭建/</id>
    <published>2019-07-02T12:52:07.000Z</published>
    <updated>2019-07-05T08:26:50.554Z</updated>
    
    <content type="html"><![CDATA[<p>如果你和我一样是小白，从来没搭建过博客。那么恭喜你！看完这篇文章，你也可以拥有一个这样的博客啦！</p><a id="more"></a><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><h2 id="搭建本地个人博客"><a href="#搭建本地个人博客" class="headerlink" title="搭建本地个人博客"></a>搭建本地个人博客</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你和我一样是小白，从来没搭建过博客。那么恭喜你！看完这篇文章，你也可以拥有一个这样的博客啦！&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://tangguangzhen.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://tangguangzhen.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
